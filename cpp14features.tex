\documentclass{beamer}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\lstset{
  language=C++,
  basicstyle=\tiny,
}
\usetheme{Warsaw}
\title{New Features in C++14}
\author{Mochan Shrestha}
\institute{Ann Arbor C++ Meetup}
\date{June 24, 2015}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[Introduction]
 \begin{enumerate}
  \item C++14 is a minor release.
  \item Builds up on C++11 
 \end{enumerate}
\end{frame}

\begin{frame}{[[deprecated]] attribute}
 \begin{enumerate}
  \item Adding \texttt{[[deprecated]]} produces a compiler warning
 \end{enumerate}
\end{frame}

\begin{frame}{Binary Literals}
 \begin{enumerate}
  \item We have decimal, hex and octal support. Now binary is supported
  \item \texttt{int x = 0b1111101011001110}
 \end{enumerate}
\end{frame}

\begin{frame}{Digit Seperator}
 \begin{enumerate}
  \item Use single quotes to seperate digits for ease of reading
  \item \texttt{int x = 0b1111'1010'1100'1110}
  \item Location of single quote doesn't matter. Ignored by compiler
  \item \texttt{int x = 3'00.0}
 \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Variable Templates}
 \begin{enumerate}
  \item Variable type can now also be templated.
  \begin{lstlisting}
   template <typename T>
   T pi = 3.14159;
  \end{lstlisting}
 \end{enumerate}
\end{frame}


\begin{frame}{Return Type Deduction}
\begin{enumerate}
  \item C++11 introduced the new keyword \texttt{auto}
  \item C++14 exapnds it for return types as well
  \item Still same compile-time type safety
\end{enumerate}
\end{frame}

\begin{frame}{Return Type Deduction}
 \begin{enumerate}
  \item C++11 also introduced \texttt{decltype}
  \item C++14 now allows for \texttt{decltype(auto)}
  \item Just like in C++11, \texttt{decltype} manages to maintain the references.
 \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Relaxed constexpr Restrictions}
 \begin{enumerate}
  \item C++11 introduced \texttt{constexpr} which allowed compile time evaluation of the variables and functions.
  \item C++14 allows using \texttt{if}, \texttt{switch} and \texttt{for} among others.
 \end{enumerate}
\end{frame}


\begin{frame}[fragile]{Generic Lambdas}
 \begin{enumerate}
  \item C++11 introduced lambda functions
  \begin{lstlisting}
	vector<int> v = {1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 45};
	sort(v.begin(), v.end(), [](int i, int j) -> bool {return i>j;});
  \end{lstlisting}
  \item Parameters in the lambda function can now also be auto
  \begin{lstlisting}
	vector<int> v = {1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 45};
	auto cmpf = [](auto i, auto j) -> auto {return i>j;};
	sort(v.begin(), v.end(), cmpf);   
  \end{lstlisting}

  \item Generic lambda functions can now act as templates
 \end{enumerate}  
\end{frame}

\begin{frame}{Initalized Lambda Captures}
 \begin{enumerate}
  \item C++11 lambdas had a capture section that would take any referenced variable
  \item C++14 allows for any kind of initalization on the captured members
  \item Useful for capture by move (\texttt{std::move})
 \end{enumerate}

\end{frame}


\end{document}